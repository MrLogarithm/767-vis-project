<!DOCTYPE html>
<html>
  <head>
    <!--
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
      -->
      <script src="jquery.min.js"></script>
    <!--
      <script src="https://d3js.org/d3.v4.min.js"></script>
      -->
    <script src="d3.v4.min.js"></script>
  </head>
  <meta charset="UTF-8">
  <style>
    .node image {
      stroke: steelblue;
      stroke-width: 3px;
    }

    .node text {
      font: 12px sans-serif;
    }

    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
    }
  </style>
  <body>

  <div id="embedding_window">
    Sign embedding space goes here.
  </div>

  <svg id="svg_trees">
    <mask id="myMask">
      <rect x="-30" y="-15" width="60" height="30" fill="white" />
    </mask>
  </svg>
  <input type="text" style="position:relative;left:-535px;top:-400px;" size=3 onchange="change_focus()" id="center_sign" value="M217"/>


  <div id="tablet_previews">
    Tablet previews will go here.
  </div>

<script>
// TODO maybe just grey out instead of hiding TODO
var ngram_counts;
var embeddings;

//////////////////////////////////////////////////
// COLLAPSIBLE TREE SETUP
//

// Set the dimensions and margins of the diagram
var margin = {top: 20, right: 90, bottom: 30, left: 90},
    width = 1000 - margin.left - margin.right,
    height = 800 - margin.top - margin.bottom;

// appends a 'group' element to 'svg'
// moves the 'group' element to the top left margin
var svg = d3.select("#svg_trees")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", 
      "translate("+ margin.left + "," + margin.top + ")"
    );

var i = 0;
var duration = 0;
var root = {"left":null, "right":null};
var prune = {"left":null, "right":null};
var selected = {"left":[], "right":[]};
var ctx = { "left": "M217", "right": "M217" };

// declares a tree layout and assigns the size
var treemap = {
  "left":  d3.tree().size([height, width/2]),
  "right": d3.tree().size([height, width/2])
  };


$().ready( function(){
  // Get ngram data as JSON:
  $.get({
     url: "https://mrlogarithm.github.io/767-vis-project/pe_ngrams.json",
     //url: "pe_ngrams.json",
     dataType:'json',
     success:function(result) {
       ngram_counts = result;
       console.log("Loaded nGram counts");
       $.get({
         url: "https://mrlogarithm.github.io/767-vis-project/pe.vec.json",
         //url: "pe.vec.json",
         dataType:'json',
         success:function(result) {
           embeddings = result;
           console.log("Loaded sign embeddings");
           setup("right");
           setup("left");
         }
       });
     }
   });
});

var corr = "corrections included";
var vars = "variants separate";

/////////////////////////
// TODO 
//
function change_focus() {
  var new_focus = document.getElementById("center_sign").value;
  ctx.left  = new_focus;
  ctx.right = new_focus;
  // change left and right contexts
  // collapse and redraw trees
  // find similar signs in embedding space
  // redraw vertical suggestion bar with similar signs
  root = {"left":null, "right":null};
  prune = {"left":null, "right":null};
  selected = {"left":[], "right":[]};
  setup("left");
  setup("right");
  console.log("hello " + new_focus);
}

/////////////////////////
// Working:
//
function get_treedata( sign, depth, dir ) {

  var children = [];
  for ( var k in ngram_counts["corrections included"]["variants separate"] ) {
    if ( (((dir == "left") && k.endsWith(" "+sign.trim())) || ((dir == "right") && k.startsWith(sign.trim()+" "))) &&
         (k.split(" ").length-1 == depth) &&
         (ngram_counts["corrections included"]["variants separate"][k] >= 1 ) 
    ) {
      children.push( get_treedata(k, depth+1, dir) );
    }
  }
  var name = sign.split(" ");
  name = (dir == "left") ? name[0] : name[name.length-1];
  if ( children == [] ) {
    return {"name":name}
  } else {
    return {"name":name,"children":children}
  }
}

//////////////////////////////////////////////////
// NEAREST NEIGHBORS SETUP
//

function cosine( u, v ) {
  var sum   = 0;
  var len_u = 0;
  var len_v = 0;
  for ( var i = 0; i < u.length; i++ ) {
    sum   += u[i] * v[i];
    len_u += u[i] * u[i];
    len_v += v[i] * v[i];
  }
  return sum / ( Math.sqrt(len_u) * Math.sqrt(len_v) );
}

function get_nns( sign, top_k = 5 ) {
  var sign_embedding = embeddings[sign];
  var nns = [];
  for ( var key in embeddings ) {
    var similarity = cosine( embeddings[key], sign_embed );
    nns.push( [similarity, key] );
  }
  nns.sort().reverse();
  return nns.slice(0,top_k);
}






function setup( dir, reselect=false ) {
  // Full tree rooted in focussed sign:
  var treeData = get_treedata(
    document.getElementById("center_sign").value,
    document.getElementById("center_sign").value.split(" ").length,
    dir
  );

  root[dir]  = d3.hierarchy(
    treeData, 
    function(d) { return d.children; }
  );
  root[dir].x0 = height / 2;
  root[dir].y0 = width / 2;
  root[dir].data.name = document.getElementById("center_sign").value;

  root[dir].all_children = root[dir].children;
  // Collapse after the second level
  if (root[dir].children) {
    root[dir].children.forEach(collapse);
    root[dir].children.forEach(function(d){expand_selected(d, dir);});
  }
  update(root[dir],  dir, propagate=false, reselect=reselect);
  refresh_pruned_tree(dir);
  recolor(root[dir],dir,prune[dir]);
}
function refresh_pruned_tree( dir ) {
  // Tree data constrained by the current selection:
  var otherDir = (dir == "left") ? "right" : "left";
  var treeData_pruned = get_treedata(
    ctx[otherDir],
    ctx[otherDir].split(" ").length, 
    dir
  );
  prune[dir] = d3.hierarchy(treeData_pruned, function(d){ return d.children});
}
function recolor(node,dir,prune) {
  // root is always in common
  // for each child, if not exist, remove click() and grey out
  //console.log("pruning to:");
  //console.log(prune);
    if ( node.children ) {
      for ( var i = 0; i < node.children.length; i++ ) {
	console.log("Should I prune"+node.children[i].data.name+"?");
	var found = false;
       if (prune.children){
	for ( var k = 0; k < prune.children.length; k++ ) {
	  if ( node.children[i].data.name == prune.children[k].data.name ) {
	    found = true;
	    break;
	  }
       }}
	if (found) {
	console.log("No!");
          //d3.selectAll("#"+dir+"_"+(node.depth+1)+"_"+node.children[i].data.name+"_img").style("filter","invert(0)");
	} else {
	  console.log("Yes!");
          d3.selectAll("#"+dir+"_"+(node.depth+1)+"_"+node.children[i].data.name).style("fill","#555");
          //d3.selectAll("#"+dir+"_"+(node.depth+1)+"_"+node.children[i].data.name+"_img").style("filter","invert(1)");
	}
      }
    }
}

function expand_selected(d, dir) {
  //console.log(d.data.name);
  //console.log("selected["+dir+"]:");
  //console.log(selected[dir]);
  if ( (selected[dir][d.depth]) && (selected[dir][d.depth].data.name == d.data.name) ) {
    console.log("I should expand the node " + d.data.name);
    d.children = d._children;
    if (d.children) {
      d.children.forEach(collapse);
      d.children.forEach(function(dd){expand_selected(dd,dir)});
    }
    } else if (d.children) {
      d.children.forEach(collapse);
    }
}

// Collapse the node and all it's children
function collapse(d) {
  if(d.children) {
    d._children = d.children
    d._children.forEach(collapse)
    d.children = null
  }
}

function update(source, dir="right", propagate=false, reselect=false) {

  //console.log("Reselect?");
  //console.log(reselect);
  //console.log("Propagate?");
  //console.log(propagate);
  // todo get list of parent nodes - these specify the search string
  // update list of tablet previews with this string

  // Assigns the x and y position for the nodes
  var treeData = treemap[dir](root[dir]);

  // Compute the new tree layout.
    var nodes = treeData.descendants().filter( function(d){return true;}),
      links = treeData.descendants().filter( function(d){return true;}).slice(1);

  // Normalize for fixed-depth.
  var LAYER_SPACE, ROOT_OFFSET;
  if ( dir == "left" ) {
    LAYER_SPACE = -50;
    ROOT_OFFSET = 0;
  } else {
    LAYER_SPACE = 50;
    ROOT_OFFSET = 0;
  }
  nodes.forEach(function(d){ d.y = (ROOT_OFFSET + width / 2) + d.depth * LAYER_SPACE; });
  if ( reselect ) {
    console.log("Not changing the selection, because I'm just pruning the tree");
  } else {
    if ( source.children ) {
      console.log("I think you expanded " + source.data.name);
      selected[dir] = [source];
      ctx[dir] = source.data.name;
    } else {
      console.log("I think you collapsed " + source.data.name);
      selected[dir] = [];
      ctx[dir] = "";
    }
    if (source.depth > 0) {
      var ptr = source;
      while ( ptr.parent !== null ) {
        ptr = ptr.parent;
        selected[dir].push(ptr);
        if ( dir == "left" ) {
          ctx[dir] += " " + ptr.data.name;
        } else {
          ctx[dir] = ptr.data.name + " " + ctx[dir];
        }
      }
    }
    ctx[dir] = ctx[dir].trim();
    selected[dir].reverse();
  }
  if (propagate) {
    console.log("need to update ~"+dir+"  tree with ctx " + ctx[dir]);
    var otherDir = ( dir == "left" ) ? "right" : "left";
    //setup( otherDir, reselect=true );
    update(root[otherDir],  otherDir, propagate=false, reselect=true);
    refresh_pruned_tree(otherDir);
    recolor(root[otherDir],otherDir,prune[otherDir]);
  }
  ctx[dir] = ctx[dir].trim();
  console.log(ctx[dir], dir);

  // ****************** Nodes section ***************************

  // Update the nodes...
  var node = svg.selectAll('g.node.'+dir)
      .data(nodes, function(d) {return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append('g')
      .attr('class', 'node '+dir)
      .attr("transform", function(d) {
        return "translate(" + source.y0 + "," + source.x0 + ")";
       });

  nodeEnter
      .filter(function(d){
	return (d.children || d._children)
      })
      .on('click', function(d){click(d,dir)})
      .attr('cursor', 'pointer')
  ;

  var imgsize = 40;
  // Add Circle for the nodes
  nodeEnter
      .filter(function(d){
        return d.parent;
      })
      .append('circle')
      .attr('id', function(d){return dir+"_"+d.depth+"_"+d.data.name})
      .attr('class', "node "+dir)
      .attr('r', imgsize/1.9)
      .style("fill","red")
      .attr('cy', 0)
      .attr('cx',imgsize/2 - (dir=="left"?imgsize:0))
      .attr('width', imgsize)
      .attr('height', imgsize)
  ;
  nodeEnter
      .filter(function(d){
        return d.parent;
      })
      .append('image')
      .attr('id', function(d){return dir+"_"+d.depth+"_"+d.data.name+"_img"})
      .attr('y', -imgsize/2)
      .attr('x',(dir=="left")?-imgsize:0)
      .attr('width', imgsize)
      .attr('height', imgsize)
      .attr("href",function(d){return "pngs/PE_mainforms/"+d.data.name+".trans.png";})
  ;

  // Add labels for the nodes
  nodeEnter.append('text')
        .attr("dy", function(d) {
          return ( d.data.name == "unk" || d.data.name == "X" )
	    ? "5"
	    : "-1.15em";
	})
        .attr("dx", function(d){
	  return (dir=="left")
	    ? -imgsize/2
	    :  imgsize/2
        })
        .attr("text-anchor", "middle")
        .text(function(d) {
          return (d.depth == 0) 
	    ? "" 
	    : (d.children || d._children 
	      ? d.data.name.replace("unk","[...]")
	      : "" ); 
        });

  // UPDATE
  var nodeUpdate = nodeEnter.merge(node);

  // Transition to the proper position for the node
  nodeUpdate.transition()
    .duration(duration)
    .attr("transform", function(d) { 
        return "translate(" + d.y + "," + d.x + ")";
     });

  /*
  // Update the node attributes and style
  nodeUpdate.select('circle.node.'+dir)
    //.attr('r', 10)
    //.style("fill", function(d) {
        //return d._children ? "lightsteelblue" : "#fff";
    //})
  ;*/


  // Remove any exiting nodes
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) {
          return "translate(" + source.y + "," + source.x + ")";
      })
      .remove();

  // On exit reduce the opacity of text labels
  nodeExit.select('text')
    .style('fill-opacity', 1e-6);

  // ****************** links section ***************************

  // Update the links...
  var link = svg.selectAll('path.link.'+dir)
      .data(links, function(d) { return d.id; });

  // Enter any new links at the parent's previous position.
  var linkEnter = link.enter().insert('path', "g")
      .attr("class", "link "+dir)
      .attr('d', function(d){
        var o = {x: source.x0, y: source.y0}
        return diagonal(o, o)
      });

  // UPDATE
  var linkUpdate = linkEnter.merge(link);

  // Transition back to the parent element position
  linkUpdate.transition()
      .duration(duration)
      .attr('d', function(d){ return diagonal(d, d.parent) });

  // Remove any exiting links
  var linkExit = link.exit().transition()
      .duration(duration)
      .attr('d', function(d) {
        var o = {x: source.x, y: source.y}
        return diagonal(o, o)
      })
      .remove();

  // Store the old positions for transition.
  nodes.forEach(function(d){
    d.x0 = d.x;
    d.y0 = d.y;
  });

  // Creates a curved (diagonal) path from parent to the child nodes
  function diagonal(s, d) {

    path = `M ${s.y} ${s.x}
            C ${(s.y + d.y) / 2} ${s.x},
              ${(s.y + d.y) / 2} ${d.x},
              ${d.y} ${d.x}`

    return path
  }


  d3.selectAll("circle.node."+dir).style("fill",function(d){
    if (( selected[dir][d.depth] ) && (selected[dir][d.depth].data.name == d.data.name )) {
      return "#afa";
    } else {
      return d.children||d._children ? "lightsteelblue" : "#000";
    }
  });

  refresh_pruned_tree(dir);
  recolor(root[dir],dir,prune[dir]);
}
  // Toggle children on click.
  function click(d, dir) {
    if (d.children) {
      d._children = d.children;
      d.children = null;
    } else {
      d.children = d._children;
      if (d.children){
        d.children.forEach(collapse);
      }
      d._children = null;
    }
    // Collapse sibling nodes to save space
    // TODO Option to disable this? Might
    // want to compare multiple subtrees.
    /*
    if ( d.parent ) {
      d.parent.children.filter(
	function(dd){
	  return d.data.name != dd.data.name
	}).forEach(collapse);
    }
    */
    console.log("updating other side:");
    console.log("source is");
    console.log(d);
    console.log(dir);
    update(d,dir=dir,propagate=true,reselect=false);
  }
  // Toggle children on click.

</script>
</body>
</html>

</>
