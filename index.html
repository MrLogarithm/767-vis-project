<!DOCTYPE html>
<html>
  <head>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
  </head>
  <meta charset="UTF-8">
  <style>
    .node image {
      stroke: steelblue;
      stroke-width: 3px;
    }

    .node text {
      font: 12px sans-serif;
    }

    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
    }
  </style>
  <body>

  <input type="text" style="position:absolute;left:480px;top:385px;" size=3 onchange="change_focus()" id="center_sign" value="M217"/>

  <svg id="svg_trees">
  </svg>

  <div id="tablet_previews">
    Tablet previews will go here.
  </div>

<script>
// TODO maybe just grey out instead of hiding TODO
var ngram_counts;
var embeddings;

//////////////////////////////////////////////////
// COLLAPSIBLE TREE SETUP
//

// Set the dimensions and margins of the diagram
var margin = {top: 20, right: 90, bottom: 30, left: 90},
    width = 1000 - margin.left - margin.right,
    height = 800 - margin.top - margin.bottom;

// appends a 'group' element to 'svg'
// moves the 'group' element to the top left margin
var svg = d3.select("#svg_trees")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", 
      "translate("+ margin.left + "," + margin.top + ")"
    );

var i = 0;
var duration = 0;
var root = {"left":null, "right":null};
var prune = {"left":null, "right":null};
var selected = {"left":[], "right":[]};
var ctx = { "left": "M217", "right": "M217" };

// declares a tree layout and assigns the size
var treemap = {
  "left":  d3.tree().size([height, width/2]),
  "right": d3.tree().size([height, width/2])
  };


$().ready( function(){
  // Get ngram data as JSON:
  $.get({
     url: "https://mrlogarithm.github.io/767-vis-project/pe_ngrams.json",
     dataType:'json',
     success:function(result) {
       ngram_counts = result;
       console.log("Loaded nGram counts");
       $.get({
         url: "https://mrlogarithm.github.io/767-vis-project/pe.vec.json",
         dataType:'json',
         success:function(result) {
           embeddings = result;
           console.log("Loaded sign embeddings");
           setup("right");
           setup("left");
         }
       });
     }
   });
});

var corr = "corrections included";
var vars = "variants separate";

/////////////////////////
// TODO 
//
function change_focus() {
  var new_focus = document.getElementById("center_sign").value;
  ctx.left  = new_focus;
  ctx.right = new_focus;
  // change left and right contexts
  // collapse and redraw trees
  // find similar signs in embedding space
  // redraw vertical suggestion bar with similar signs
  setup("left");
  setup("right");
  console.log("hello " + new_focus);
}

/////////////////////////
// Working:
//
function get_treedata( sign, depth, dir ) {

  var children = [];
  for ( var k in ngram_counts["corrections included"]["variants separate"] ) {
    if ( (((dir == "left") && k.endsWith(" "+sign.trim())) || ((dir == "right") && k.startsWith(sign.trim()+" "))) &&
         (k.split(" ").length-1 == depth) &&
         (ngram_counts["corrections included"]["variants separate"][k] >= 1 ) 
    ) {
      children.push( get_treedata(k, depth+1, dir) );
    }
  }
  var name = sign.split(" ");
  name = (dir == "left") ? name[0] : name[name.length-1];
  if ( children == [] ) {
    return {"name":name}
  } else {
    return {"name":name,"children":children}
  }
}

//////////////////////////////////////////////////
// NEAREST NEIGHBORS SETUP
//

function cosine( u, v ) {
  var sum   = 0;
  var len_u = 0;
  var len_v = 0;
  for ( var i = 0; i < u.length; i++ ) {
    sum   += u[i] * v[i];
    len_u += u[i] * u[i];
    len_v += v[i] * v[i];
  }
  return sum / ( Math.sqrt(len_u) * Math.sqrt(len_v) );
}

function get_nns( sign, top_k = 5 ) {
  var sign_embedding = embeddings[sign];
  var nns = [];
  for ( var key in embeddings ) {
    var similarity = cosine( embeddings[key], sign_embed );
    nns.push( [similarity, key] );
  }
  nns.sort().reverse();
  return nns.slice(0,top_k);
}






function setup( dir, reselect=false ) {
  // Full tree rooted in focussed sign:
  var treeData = get_treedata(
    document.getElementById("center_sign").value,
    1,
    dir
  );

    root[dir]  = d3.hierarchy(
    treeData, 
    function(d) { return d.children; }
  );
  root[dir].x0 = height / 2;
  root[dir].y0 = width / 2;

  root[dir].all_children = root[dir].children;
  // Collapse after the second level
  if (root[dir].children) {
    root[dir].children.forEach(collapse);
    root[dir].children.forEach(function(d){expand_selected(d, dir);});
  }
  update(root[dir],  dir, propagate=false, reselect=reselect);
  refresh_pruned_tree(dir);
  recolor(root[dir],dir,prune[dir]);
}
function refresh_pruned_tree( dir ) {
  // Tree data constrained by the current selection:
  var otherDir = (dir == "left") ? "right" : "left";
  var treeData_pruned = get_treedata(
    ctx[otherDir],
    ctx[otherDir].split(" ").length, 
    dir
  );
  prune[dir] = d3.hierarchy(treeData_pruned, function(d){ return d.children});
}
function recolor(node,dir,prune) {
    // root is always in common
    // for each child, if not exist, remove click() and grey out
  console.log("pruning to:");
  console.log(prune);
    if ( node.children ) {
      for ( var i = 0; i < node.children.length; i++ ) {
	console.log("Should I prune"+node.children[i].data.name+"?");
	var found = false;
       if (prune.children){
	for ( var k = 0; k < prune.children.length; k++ ) {
	  if ( node.children[i].data.name == prune.children[k].data.name ) {
	    found = true;
	    break;
	  }
       }}
	if (found) {
	console.log("No!");
	  //d3.selectAll("#"+dir+"_"+(node.depth+1)+"_"+node.children[i].data.name).on("click",function(d){click(d,dir)});
	} else {
	  console.log("Yes!");
          d3.selectAll("#"+dir+"_"+(node.depth+1)+"_"+node.children[i].data.name).style("fill","#222");
          //d3.selectAll("#"+dir+"_"+(node.depth+1)+"_"+node.children[i].data.name).on("click",null);
	}
      }
    }
}

function expand_selected(d, dir) {
  //console.log(d.data.name);
  //console.log("selected["+dir+"]:");
  //console.log(selected[dir]);
  if ( (selected[dir][d.depth]) && (selected[dir][d.depth].data.name == d.data.name) ) {
    console.log("I should expand the node " + d.data.name);
    d.children = d._children;
    if (d.children) {
      d.children.forEach(collapse);
      d.children.forEach(function(dd){expand_selected(dd,dir)});
    }
    } else if (d.children) {
      d.children.forEach(collapse);
    }
}

// Collapse the node and all it's children
function collapse(d) {
  if(d.children) {
    d._children = d.children
    d._children.forEach(collapse)
    d.children = null
  }
}

function update(source, dir="right", propagate=false, reselect=false) {

  //console.log("Reselect?");
  //console.log(reselect);
  //console.log("Propagate?");
  //console.log(propagate);
  // todo get list of parent nodes - these specify the search string
  // update list of tablet previews with this string

  // Assigns the x and y position for the nodes
  var treeData = treemap[dir](root[dir]);

  // Compute the new tree layout.
    var nodes = treeData.descendants().filter( function(d){return true;}),
      links = treeData.descendants().filter( function(d){return true;}).slice(1);

  // Normalize for fixed-depth.
  var LAYER_SPACE, ROOT_OFFSET;
  if ( dir == "left" ) {
    LAYER_SPACE = -100;
    ROOT_OFFSET = 0;
  } else {
    LAYER_SPACE = 100;
    ROOT_OFFSET = 0;
  }
  nodes.forEach(function(d){ d.y = (ROOT_OFFSET + width / 2) + d.depth * LAYER_SPACE; });
  if ( reselect ) {
    console.log("Not changing the selection, because I'm just pruning the tree");
  } else {
    if ( source.children ) {
      console.log("I think you expanded " + source.data.name);
      selected[dir] = [source];
      ctx[dir] = source.data.name;
    } else {
      console.log("I think you collapsed " + source.data.name);
      selected[dir] = [];
      ctx[dir] = "";
    }
    if (source.depth > 0) {
      var ptr = source;
      while ( ptr.parent !== null ) {
        ptr = ptr.parent;
        selected[dir].push(ptr);
        if ( dir == "left" ) {
          ctx[dir] += " " + ptr.data.name;
        } else {
          ctx[dir] = ptr.data.name + " " + ctx[dir];
        }
      }
    }
    ctx[dir] = ctx[dir].trim();
    selected[dir].reverse();
  }
  if (propagate) {
    console.log("need to update ~"+dir+"  tree with ctx " + ctx[dir]);
    var otherDir = ( dir == "left" ) ? "right" : "left";
    //setup( otherDir, reselect=true );
    update(root[otherDir],  otherDir, propagate=false, reselect=true);
    refresh_pruned_tree(otherDir);
    recolor(root[otherDir],otherDir,prune[otherDir]);
  }
  ctx[dir] = ctx[dir].trim();
  console.log(ctx[dir], dir);

  // ****************** Nodes section ***************************

  // Update the nodes...
  var node = svg.selectAll('g.node.'+dir)
      .data(nodes, function(d) {return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append('g')
      .attr('class', 'node '+dir)
      .attr("transform", function(d) {
        return "translate(" + source.y0 + "," + source.x0 + ")";
       })
      .on('click', function(d){click(d,dir)});

var imgsize = 50;
  // Add Circle for the nodes
  nodeEnter.append('image')
      .attr('class', "node "+dir)
      .attr('id', function(d){return dir+"_"+d.depth+"_"+d.data.name})
      //.attr('r', 1e-6)
      .attr('y', -imgsize/2)
      .attr('width', imgsize)
      .attr('height', imgsize)
      .attr("href",function(d){return "pngs/PE_mainforms/"+d.data.name+".png";})
      .style("mix-blend-mode","darken")
      .style("fill","#0f0")
      .style("background-color","#0f0")
      //.style("fill", function(d) {
          //return d._children ? "lightsteelblue" : "#fff";
      //})
  ;

  // Add labels for the nodes
  nodeEnter.append('text')
      .attr("dy", "-1.25em")
      .attr("dx", "3em")
      .attr("x", function(d) {
          return d.children || d._children ? -13 : 13;
      })
      .attr("text-anchor", function(d) {
          //return d.children || d._children ? "end" : "start";
	return "middle";
      })
      .text(function(d) { return d.data.name; });

  // UPDATE
  var nodeUpdate = nodeEnter.merge(node);

  // Transition to the proper position for the node
  nodeUpdate.transition()
    .duration(duration)
    .attr("transform", function(d) { 
        return "translate(" + d.y + "," + d.x + ")";
     });

  // Update the node attributes and style
  nodeUpdate.select('image.node.'+dir)
    .attr('r', 10)
    //.style("fill", function(d) {
        //return d._children ? "lightsteelblue" : "#fff";
    //})
    .attr('cursor', 'pointer');


  // Remove any exiting nodes
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) {
          return "translate(" + source.y + "," + source.x + ")";
      })
      .remove();

  // On exit reduce the node images size to 0
  nodeExit.select('image')
    .attr('r', 1e-6);

  // On exit reduce the opacity of text labels
  nodeExit.select('text')
    .style('fill-opacity', 1e-6);

  // ****************** links section ***************************

  // Update the links...
  var link = svg.selectAll('path.link.'+dir)
      .data(links, function(d) { return d.id; });

  // Enter any new links at the parent's previous position.
  var linkEnter = link.enter().insert('path', "g")
      .attr("class", "link "+dir)
      .attr('d', function(d){
        var o = {x: source.x0, y: source.y0}
        return diagonal(o, o)
      });

  // UPDATE
  var linkUpdate = linkEnter.merge(link);

  // Transition back to the parent element position
  linkUpdate.transition()
      .duration(duration)
      .attr('d', function(d){ return diagonal(d, d.parent) });

  // Remove any exiting links
  var linkExit = link.exit().transition()
      .duration(duration)
      .attr('d', function(d) {
        var o = {x: source.x, y: source.y}
        return diagonal(o, o)
      })
      .remove();

  // Store the old positions for transition.
  nodes.forEach(function(d){
    d.x0 = d.x;
    d.y0 = d.y;
  });

  // Creates a curved (diagonal) path from parent to the child nodes
  function diagonal(s, d) {

    path = `M ${s.y} ${s.x}
            C ${(s.y + d.y) / 2} ${s.x},
              ${(s.y + d.y) / 2} ${d.x},
              ${d.y} ${d.x}`

    return path
  }


  d3.selectAll("image.node."+dir).style("fill",function(d){
    if (( selected[dir][d.depth] ) && (selected[dir][d.depth].data.name == d.data.name )) {
      return "#afa";
    } else {
      return d._children ? "lightsteelblue" : "#fff";
    }
  });

  refresh_pruned_tree(dir);
  recolor(root[dir],dir,prune[dir]);
}
  // Toggle children on click.
  function click(d, dir) {
    if (d.children) {
      d._children = d.children;
      d.children = null;
    } else {
      d.children = d._children;
      if (d.children){
        d.children.forEach(collapse);
      }
      d._children = null;
    }
    console.log("updating other side:");
    console.log("source is");
    console.log(d);
    console.log(dir);
    update(d,dir=dir,propagate=true,reselect=false);
  }
  // Toggle children on click.

</script>
</body>
</html>

</>
